<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=1280">
    <title>Prism Glass</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #000;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        .back-btn {
            position: fixed;
            top: 16px;
            right: 16px;
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 52px;
            height: 52px;
            padding: 0;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.25);
            border-radius: 12px;
            cursor: pointer;
            color: rgba(255, 255, 255, 0.8);
            text-decoration: none;
            transition: background 0.3s ease, border-color 0.3s ease;
            backdrop-filter: blur(8px);
        }
        .back-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.4);
            color: #fff;
        }
        .back-btn svg {
            width: 28px;
            height: 28px;
            transition: transform 0.4s ease;
        }
        .back-btn:active svg {
            transform: rotate(360deg);
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-btn" title="Back to Cube">
        <svg viewBox="0 0 24 24" stroke="currentColor" stroke-width="1.5" stroke-linejoin="round">
            <path d="M12 2L20 7L12 12L4 7Z" fill="rgba(255,255,255,0.15)"/>
            <path d="M20 7V17L12 22V12Z" fill="rgba(255,255,255,0.08)"/>
            <path d="M4 7V17L12 22V12Z" fill="rgba(255,255,255,0.03)"/>
        </svg>
    </a>
    <canvas id="glcanvas"></canvas>

    <!-- Vertex Shader -->
    <script id="vertex-shader" type="x-shader/x-vertex">
        attribute vec2 position;
        void main() {
            gl_Position = vec4(position, 0.0, 1.0);
        }
    </script>

    <!-- Fragment Shader -->
    <script id="fragment-shader" type="x-shader/x-fragment">
        #ifdef GL_ES
        precision mediump float;
        #endif

        uniform vec2 iResolution;
        uniform float iTime;
        uniform vec2 iMouse;

        // --- Rotation matrices ---
        mat2 rot(float a) {
            float s = sin(a), c = cos(a);
            return mat2(c, -s, s, c);
        }

        // --- SDF primitives ---
        // Triangular prism along Z axis, base width w, height h
        float sdTriPrism(vec3 p, float w, float h) {
            vec3 q = abs(p);
            return max(q.z - h, max(q.x * 0.866025 + p.y * 0.5, -p.y) - w * 0.5);
        }

        float sdSphere(vec3 p, float r) {
            return length(p) - r;
        }

        float sdBox(vec3 p, vec3 b) {
            vec3 q = abs(p) - b;
            return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);
        }

        float sdRoundBox(vec3 p, vec3 b, float r) {
            return sdBox(p, b) - r;
        }

        // Smooth min for blending SDFs
        float smin(float a, float b, float k) {
            float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);
            return mix(b, a, h) - k * h * (1.0 - h);
        }

        // --- Scene SDF ---
        // Returns vec2(distance, materialID)
        // mat 0 = prism (glass), mat 1 = glass panels, mat 2 = glass orbs
        vec2 mapScene(vec3 p) {
            float t = iTime * 0.3;

            // Central prism - slowly rotating
            vec3 pp = p;
            pp.xz *= rot(t);
            pp.yz *= rot(t * 0.7);
            float prism = sdTriPrism(pp, 1.0, 0.8);
            vec2 res = vec2(prism, 0.0);

            // Floating glass panels
            for (float i = 0.0; i < 3.0; i++) {
                float angle = t * 0.5 + i * 2.094;
                float radius = 2.2 + 0.3 * sin(t + i);
                vec3 panelPos = p - vec3(cos(angle) * radius, sin(t * 0.4 + i) * 0.8, sin(angle) * radius);
                panelPos.xz *= rot(angle);
                panelPos.yz *= rot(t * 0.3 + i);
                float panel = sdRoundBox(panelPos, vec3(0.6, 0.4, 0.04), 0.03);
                if (panel < res.x) {
                    res = vec2(panel, 1.0);
                }
            }

            // Glass orbs
            for (float i = 0.0; i < 4.0; i++) {
                float angle = -t * 0.4 + i * 1.5708;
                float radius = 1.8 + 0.4 * cos(t * 0.6 + i * 2.0);
                float yOff = sin(t * 0.5 + i * 1.3) * 1.0;
                vec3 orbPos = p - vec3(cos(angle) * radius, yOff, sin(angle) * radius);
                float orb = sdSphere(orbPos, 0.2 + 0.05 * sin(t + i));
                if (orb < res.x) {
                    res = vec2(orb, 2.0);
                }
            }

            return res;
        }

        // --- Normal calculation ---
        vec3 calcNormal(vec3 p) {
            vec2 e = vec2(0.001, 0.0);
            return normalize(vec3(
                mapScene(p + e.xyy).x - mapScene(p - e.xyy).x,
                mapScene(p + e.yxy).x - mapScene(p - e.yxy).x,
                mapScene(p + e.yyx).x - mapScene(p - e.yyx).x
            ));
        }

        // --- Fresnel ---
        float fresnel(vec3 viewDir, vec3 normal, float power) {
            return pow(1.0 - max(dot(-viewDir, normal), 0.0), power);
        }

        // --- Rainbow color from wavelength-like parameter ---
        vec3 rainbow(float t) {
            return 0.5 + 0.5 * cos(6.28318 * (t + vec3(0.0, 0.33, 0.67)));
        }

        // --- Background: subtle gradient with dispersed light beams ---
        vec3 background(vec3 rd) {
            float t = iTime * 0.2;

            // Base dark gradient
            vec3 col = mix(vec3(0.02, 0.01, 0.04), vec3(0.04, 0.02, 0.08), rd.y * 0.5 + 0.5);

            // Rainbow caustic beams from prism dispersion
            for (float i = 0.0; i < 6.0; i++) {
                float angle = i * 0.5236 + t;
                vec3 beamDir = normalize(vec3(cos(angle), sin(angle) * 0.3 - 0.2, sin(angle)));
                float beam = pow(max(dot(rd, beamDir), 0.0), 40.0);
                col += rainbow(i / 6.0 + t * 0.1) * beam * 0.4;
            }

            // Subtle starfield
            vec2 suv = rd.xz / (rd.y + 1.0);
            float stars = smoothstep(0.98, 1.0, sin(suv.x * 50.0) * sin(suv.y * 50.0));
            col += stars * 0.15;

            return col;
        }

        // --- Chromatic refraction: trace separate R, G, B with different IOR ---
        vec3 chromaticRefract(vec3 rd, vec3 normal) {
            float iorR = 1.42;
            float iorG = 1.45;
            float iorB = 1.48;

            vec3 refR = refract(rd, normal, 1.0 / iorR);
            vec3 refG = refract(rd, normal, 1.0 / iorG);
            vec3 refB = refract(rd, normal, 1.0 / iorB);

            // Sample background along each refracted direction
            float r = background(refR).r;
            float g = background(refG).g;
            float b = background(refB).b;

            return vec3(r, g, b);
        }

        void main() {
            vec2 uv = (gl_FragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;

            // Camera
            vec3 ro = vec3(0.0, 0.0, -5.0);
            vec3 rd = normalize(vec3(uv, 1.5));

            // Mouse interaction for orbit
            vec2 m = (iMouse.xy / iResolution.xy) * 2.0 - 1.0;
            float yRot = iTime * 0.15 + m.x * 2.0;
            float xRot = m.y * 1.5;

            ro.yz *= rot(xRot);
            rd.yz *= rot(xRot);
            ro.xz *= rot(yRot);
            rd.xz *= rot(yRot);

            // --- Ray march ---
            float totalDist = 0.0;
            vec2 hit = vec2(100.0, -1.0);
            vec3 hitPos;

            for (int i = 0; i < 80; i++) {
                hitPos = ro + rd * totalDist;
                hit = mapScene(hitPos);
                if (hit.x < 0.001) break;
                totalDist += hit.x;
                if (totalDist > 20.0) break;
            }

            vec3 col;

            if (totalDist < 20.0 && hit.x < 0.001) {
                // Hit a surface
                vec3 p = hitPos;
                vec3 n = calcNormal(p);
                float mat = hit.y;

                // Dual light sources
                vec3 light1 = normalize(vec3(2.0, 3.0, -1.0));
                vec3 light2 = normalize(vec3(-1.5, 1.0, 2.0));
                vec3 light1Col = vec3(1.0, 0.95, 0.9);
                vec3 light2Col = vec3(0.7, 0.8, 1.0);

                // Fresnel edge glow
                float fres = fresnel(rd, n, 3.0);

                // Specular highlights
                vec3 halfDir1 = normalize(light1 - rd);
                vec3 halfDir2 = normalize(light2 - rd);
                float spec1 = pow(max(dot(n, halfDir1), 0.0), 64.0);
                float spec2 = pow(max(dot(n, halfDir2), 0.0), 64.0);

                // Diffuse
                float diff1 = max(dot(n, light1), 0.0);
                float diff2 = max(dot(n, light2), 0.0);

                if (mat < 0.5) {
                    // === Prism (glass with chromatic dispersion) ===
                    // Chromatic refraction through the prism
                    vec3 refracted = chromaticRefract(rd, n);

                    // Reflection
                    vec3 refl = reflect(rd, n);
                    vec3 reflCol = background(refl);

                    // Mix refraction and reflection via Fresnel
                    col = mix(refracted, reflCol, fres * 0.7);

                    // Rainbow caustics on the prism surface
                    float caustic = sin(dot(p, vec3(3.0, 5.0, 7.0)) + iTime * 2.0) * 0.5 + 0.5;
                    col += rainbow(caustic + iTime * 0.1) * 0.15 * (1.0 - fres);

                    // Specular
                    col += light1Col * spec1 * 1.2 + light2Col * spec2 * 0.8;

                    // Translucent glass edge glow
                    col += vec3(0.6, 0.7, 1.0) * fres * 0.5;

                } else if (mat < 1.5) {
                    // === Glass panels (frosted glassmorphism) ===
                    // Frosted glass look: blurred refraction approximation
                    vec3 refracted = chromaticRefract(rd, n);

                    // "Frost" by mixing with a muted base color
                    vec3 frost = mix(vec3(0.15, 0.12, 0.2), refracted, 0.4);

                    // Reflection
                    vec3 refl = reflect(rd, n);
                    vec3 reflCol = background(refl);

                    col = mix(frost, reflCol, fres * 0.5);

                    // Subtle diffuse lighting for frosted feel
                    col += vec3(0.08, 0.06, 0.12) * (diff1 * 0.5 + diff2 * 0.3);

                    // Specular — softer for frosted glass
                    float softSpec1 = pow(max(dot(n, halfDir1), 0.0), 24.0);
                    float softSpec2 = pow(max(dot(n, halfDir2), 0.0), 24.0);
                    col += light1Col * softSpec1 * 0.6 + light2Col * softSpec2 * 0.4;

                    // Edge glow
                    col += vec3(0.5, 0.6, 0.9) * fres * 0.4;

                } else {
                    // === Glass orbs ===
                    // Clear glass orbs with strong chromatic refraction
                    vec3 refracted = chromaticRefract(rd, n);

                    vec3 refl = reflect(rd, n);
                    vec3 reflCol = background(refl);

                    col = mix(refracted * 1.2, reflCol, fres * 0.6);

                    // Internal rainbow caustics
                    float orbCaustic = sin(length(p) * 10.0 - iTime * 3.0) * 0.5 + 0.5;
                    col += rainbow(orbCaustic) * 0.2 * (1.0 - fres);

                    // Specular highlights — sharp for clear glass
                    col += light1Col * spec1 * 1.5 + light2Col * spec2 * 1.0;

                    // Bright Fresnel edge
                    col += vec3(0.7, 0.8, 1.0) * fres * 0.6;
                }

            } else {
                // Background
                col = background(rd);
            }

            // Tone mapping and gamma
            col = col / (col + 1.0);
            col = pow(col, vec3(0.85));

            gl_FragColor = vec4(col, 1.0);
        }
    </script>

    <script>
        const canvas = document.getElementById('glcanvas');
        const gl = canvas.getContext('webgl');

        if (!gl) { alert('WebGL not supported'); }

        // --- Boilerplate ---
        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(shader));
                gl.deleteShader(shader); return null;
            }
            return shader;
        }

        const program = gl.createProgram();
        const vs = createShader(gl, gl.VERTEX_SHADER, document.getElementById('vertex-shader').text);
        const fs = createShader(gl, gl.FRAGMENT_SHADER, document.getElementById('fragment-shader').text);
        gl.attachShader(program, vs);
        gl.attachShader(program, fs);
        gl.linkProgram(program);

        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, 3, -1, -1, 3]), gl.STATIC_DRAW);
        const positionLoc = gl.getAttribLocation(program, 'position');
        gl.enableVertexAttribArray(positionLoc);
        gl.vertexAttribPointer(positionLoc, 2, gl.FLOAT, false, 0, 0);

        const resLoc = gl.getUniformLocation(program, 'iResolution');
        const timeLoc = gl.getUniformLocation(program, 'iTime');
        const mouseLoc = gl.getUniformLocation(program, 'iMouse');

        let mouseX = 0, mouseY = 0;
        function updateMouse(x, y) {
            mouseX = x; mouseY = y;
        }
        canvas.addEventListener('mousemove', e => updateMouse(e.clientX, e.clientY));
        canvas.addEventListener('touchmove', e => {
            e.preventDefault();
            updateMouse(e.touches[0].clientX, e.touches[0].clientY);
        }, {passive: false});

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);
        }
        window.addEventListener('resize', resize);
        resize();

        function render(time) {
            time *= 0.001;
            gl.useProgram(program);
            gl.uniform2f(resLoc, canvas.width, canvas.height);
            gl.uniform1f(timeLoc, time);
            gl.uniform2f(mouseLoc, mouseX, canvas.height - mouseY);
            gl.drawArrays(gl.TRIANGLES, 0, 3);
            requestAnimationFrame(render);
        }
        requestAnimationFrame(render);
    </script>
</body>
</html>
