#!/usr/bin/env node
// ============================================
// build-data.js — Parse docs/ markdown frontmatter → data.generated.ts
// ============================================

const fs = require('fs');
const path = require('path');
const matter = require('gray-matter');

const DOCS_DIR = path.join(__dirname, '..', 'docs');
const OUTPUT_FILE = path.join(__dirname, '..', 'src', 'typescript', 'data.generated.ts');

// Walk directory recursively, return all .md files
function walkDir(dir) {
  const results = [];
  if (!fs.existsSync(dir)) return results;
  for (const entry of fs.readdirSync(dir, { withFileTypes: true })) {
    const fullPath = path.join(dir, entry.name);
    if (entry.isDirectory()) {
      results.push(...walkDir(fullPath));
    } else if (entry.name.endsWith('.md')) {
      results.push(fullPath);
    }
  }
  return results;
}

// Extract description and example from markdown body
function parseBody(content) {
  const lines = content.split('\n');
  const descLines = [];
  const exampleLines = [];
  let inExample = false;
  let inCodeBlock = false;

  for (const line of lines) {
    if (/^##\s+Example/i.test(line)) {
      inExample = true;
      continue;
    }
    if (inExample) {
      // Capture code block content (strip ``` markers)
      if (line.startsWith('```')) {
        inCodeBlock = !inCodeBlock;
        continue;
      }
      if (inCodeBlock) {
        exampleLines.push(line);
      }
    } else {
      // Description: skip headings and empty lines at start
      if (line.startsWith('#')) continue;
      if (line.trim()) descLines.push(line.trim());
    }
  }

  return {
    description: descLines.join(' ').trim(),
    example: exampleLines.length > 0 ? exampleLines.join('\n') : undefined
  };
}

// Parse a single markdown file, return array of endpoint objects
function parseFile(filePath) {
  const raw = fs.readFileSync(filePath, 'utf-8');
  const { data, content } = matter(raw);
  const endpoints = [];

  // Multi-item file (items: array in frontmatter)
  if (data.items && Array.isArray(data.items)) {
    for (const item of data.items) {
      endpoints.push({
        id: item.id,
        type: data.type || item.type,
        method: item.method || undefined,
        name: item.name,
        path: item.path,
        summary: item.summary || '',
        description: item.description || '',
        category: data.category || item.category || '',
        parameters: item.parameters || undefined,
        example: item.example || undefined,
        requiredMcp: item.requiredMcp || undefined,
        source: item.source || data.source || undefined
      });
    }
  }
  // Single-item file
  else if (data.id || data.name) {
    const body = parseBody(content);
    const desc = data.description || body.description;
    const example = data.example || body.example;
    endpoints.push({
      id: data.id,
      type: data.type,
      method: data.method || undefined,
      name: data.name,
      path: data.path,
      summary: data.summary || '',
      description: desc,
      category: data.category || '',
      parameters: data.parameters || undefined,
      example: example || undefined,
      requiredMcp: data.requiredMcp || undefined,
      source: data.source || undefined
    });
  }

  return endpoints;
}

// Generate TypeScript source
function generateTS(mcpTools, officialSkills, communitySkills, apiEndpoints) {
  function serializeEndpoint(ep) {
    const lines = [];
    lines.push('  {');
    lines.push(`    id: ${JSON.stringify(ep.id)},`);
    lines.push(`    type: ${JSON.stringify(ep.type)},`);
    if (ep.method) lines.push(`    method: ${JSON.stringify(ep.method)},`);
    lines.push(`    name: ${JSON.stringify(ep.name)},`);
    lines.push(`    path: ${JSON.stringify(ep.path)},`);
    lines.push(`    summary: ${JSON.stringify(ep.summary)},`);
    lines.push(`    description: ${JSON.stringify(ep.description)},`);
    lines.push(`    category: ${JSON.stringify(ep.category)},`);
    if (ep.parameters && ep.parameters.length > 0) {
      lines.push(`    parameters: ${JSON.stringify(ep.parameters)},`);
    }
    if (ep.example) {
      lines.push(`    example: ${JSON.stringify(ep.example)},`);
    }
    if (ep.requiredMcp && ep.requiredMcp.length > 0) {
      lines.push(`    requiredMcp: ${JSON.stringify(ep.requiredMcp)},`);
    }
    if (ep.source) {
      lines.push(`    source: ${JSON.stringify(ep.source)},`);
    }
    lines.push('  }');
    return lines.join('\n');
  }

  function serializeArray(name, endpoints) {
    const items = endpoints.map(serializeEndpoint).join(',\n');
    return `export const ${name}: Endpoint[] = [\n${items}\n];`;
  }

  return `// AUTO-GENERATED — DO NOT EDIT
// Generated by scripts/build-data.js from docs/ markdown files

interface Endpoint {
  id: string;
  type: 'mcp' | 'skill' | 'api';
  method?: string;
  name: string;
  path: string;
  summary: string;
  description: string;
  parameters?: Parameter[];
  example?: string;
  category: string;
  requiredMcp?: string[];
  source?: string;
}

interface Parameter {
  name: string;
  type: string;
  required: boolean;
  description: string;
}

${serializeArray('mcpTools', mcpTools)}

${serializeArray('officialSkills', officialSkills)}

${serializeArray('communitySkills', communitySkills)}

${serializeArray('apiEndpoints', apiEndpoints)}

export const endpoints: Endpoint[] = [...mcpTools, ...officialSkills, ...communitySkills, ...apiEndpoints];
`;
}

// Main
function main() {
  const mcpTools = [];
  const officialSkills = [];
  const communitySkills = [];
  const apiEndpoints = [];

  // Parse claude-tools/ → mcpTools
  const claudeToolsDir = path.join(DOCS_DIR, 'claude-tools');
  for (const file of walkDir(claudeToolsDir)) {
    mcpTools.push(...parseFile(file));
  }

  // Parse skills/official/ → officialSkills
  const officialDir = path.join(DOCS_DIR, 'skills', 'official');
  for (const file of walkDir(officialDir)) {
    officialSkills.push(...parseFile(file));
  }

  // Parse skills/community/ → communitySkills
  const communityDir = path.join(DOCS_DIR, 'skills', 'community');
  for (const file of walkDir(communityDir)) {
    communitySkills.push(...parseFile(file));
  }

  // Parse apis/ endpoint files → apiEndpoints
  const apisDir = path.join(DOCS_DIR, 'apis');
  const apiEndpointFiles = ['health-monitoring.md', 'vm-management.md', 'container-management.md', 'service-management.md'];
  for (const file of walkDir(apisDir)) {
    const basename = path.basename(file);
    if (apiEndpointFiles.includes(basename)) {
      apiEndpoints.push(...parseFile(file));
    }
  }

  // Generate output
  const ts = generateTS(mcpTools, officialSkills, communitySkills, apiEndpoints);
  fs.mkdirSync(path.dirname(OUTPUT_FILE), { recursive: true });
  fs.writeFileSync(OUTPUT_FILE, ts, 'utf-8');

  console.log(`[build-data] Generated ${OUTPUT_FILE}`);
  console.log(`  MCP Tools:        ${mcpTools.length}`);
  console.log(`  Official Skills:  ${officialSkills.length}`);
  console.log(`  Community Skills: ${communitySkills.length}`);
  console.log(`  API Endpoints:    ${apiEndpoints.length}`);
  console.log(`  Total:            ${mcpTools.length + officialSkills.length + communitySkills.length + apiEndpoints.length}`);
}

main();
