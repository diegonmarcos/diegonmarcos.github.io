<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Diego's CV</title>
    <!-- Tailwind CSS for styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- PDF.js library from Mozilla CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
    <style>
        body { font-family: 'Inter', sans-serif; }
        .loader {
            border: 5px solid #f3f3f3;
            border-top: 5px solid #3498db;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        /* Make the main container scrollable with a fixed height */
        #pdf-container {
            height: calc(100vh - 100px); /* Adjust height based on header/footer */
            overflow: hidden; /* We handle panning manually, so hide default scrollbars */
        }
        #zoom-wrapper {
            transform-origin: 0 0;
            cursor: grab;
        }
        .page-container {
            margin-bottom: 1rem;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            background-color: #fff;
            position: relative; /* Needed for link overlay positioning */
        }
        .page-container canvas {
            display: block;
            margin: 0 auto;
        }
        .link-layer {
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
        }
        .link-layer a {
            position: absolute;
            display: block;
            cursor: pointer;
            /* For debugging: outline: 1px solid red; */
        }
        /* Toggle Switch CSS */
        input:checked ~ .dot {
            transform: translateX(100%);
        }
        /* Custom responsive dot position */
        @media (max-width: 639px) {
            input:checked ~ .dot {
                transform: translateX(175%);
            }
        }
        input:checked ~ .block {
            background-color: #48bb78;
        }
        /* Mobile-specific overrides */
        @media (max-width: 767px) {
            #pdf-container {
                overflow: auto; /* Enable native scrolling */
            }
            #zoom-wrapper {
                cursor: default !important; /* No grab cursor */
            }
            #reset-zoom-btn {
                display: none; /* Hide reset button */
            }
        }
    </style>
    <link rel="stylesheet" href="https://rsms.me/inter/inter.css">
</head>
<body class="bg-slate-100 dark:bg-slate-900 text-slate-800 dark:text-slate-200 flex h-screen overflow-hidden">

    <div class="flex-grow w-0 flex flex-col"> <!-- Main content wrapper -->
        <div class="w-full max-w-4xl mx-auto flex flex-col p-4 sm:p-6 h-full">
            <!-- Sticky Header and Navigation -->
            <header class="bg-white dark:bg-slate-800 shadow-lg rounded-lg px-4 py-3 sm:px-6 sm:py-4 mb-4 flex items-center justify-between flex-wrap gap-4 z-10 w-full shrink-0">
                <h1 class="text-xl font-bold text-slate-700 dark:text-slate-200 shrink-0">Diego's CV</h1>
                <div class="flex items-center justify-center flex-wrap gap-x-4 sm:gap-x-6">
                    <!-- Page Indicator -->
                    <div class="text-center font-medium">
                        <span>Page: </span><span id="page-num">1</span> / <span id="page-count">--</span>
                    }
                }
                requestAnimationFrame(animationStep);
            }

            // This is the core of the new engine. It runs all UI updates based on visual state.
            function updateUI() {
                const containerRect = ui.container.getBoundingClientRect();
                let mostVisiblePageIndex = 0;
                let maxVisibleHeight = 0;

                for (let i = 0; i < pageContainers.length; i++) {
                    const page = pageContainers[i];
                    const pageRect = page.getBoundingClientRect();
                    const isVisible = pageRect.bottom > containerRect.top && pageRect.top < containerRect.bottom;

                    if (isVisible) {
                        const pageNum = i + 1;
                        queueRender(pageNum);
                        queueRender(pageNum - 1);
                        queueRender(pageNum + 1);

                        const visibleHeight = Math.min(pageRect.bottom, containerRect.bottom) - Math.max(pageRect.top, containerRect.top);
                        if (visibleHeight > maxVisibleHeight) {
                            maxVisibleHeight = visibleHeight;
                            mostVisiblePageIndex = i;
                        }
                    }
                }
                ui.pageNumSpan.textContent = mostVisiblePageIndex + 1;
            }

            function scheduleUIUpdate() {
                if (uiUpdateTimeout) clearTimeout(uiUpdateTimeout);
                uiUpdateTimeout = setTimeout(updateUI, 50);
            }

            // --- EVENT LISTENERS ---
            ui.previewToggle.addEventListener('change', (e) => {
                linkPreviewEnabled = e.target.checked;
            });

            const isMobile = window.innerWidth <= 768;

            if (!isMobile) {
                ui.resetZoomBtn.addEventListener('click', () => {
                    isAnimating = false; // Stop any running animation

                    const currentPageIndex = parseInt(ui.pageNumSpan.textContent) - 1;
                    const targetPage = pageContainers[currentPageIndex];
                    
                    // Calculate the required pan to keep the top of the current page in view after reset.
                    // offsetTop gives the static layout position, which is what we need when scale is 1.
                    const newPanY = -targetPage.offsetTop;

                    scale = 1;
                    panX = 0;
                    panY = newPanY;
                    
                    applyTransform();
                    scheduleUIUpdate();
                });

                ui.container.addEventListener('wheel', e => {
                    isAnimating = false; // Stop animation on user input
                    e.preventDefault();
                    if (e.ctrlKey) { // Handle Zoom
                        const zoomAmount = e.deltaY * -0.005;
                        const newScale = Math.max(minScale, Math.min(scale + zoomAmount, maxScale));
                        if (newScale === scale) return;

                        const rect = ui.container.getBoundingClientRect();
                        const computedStyle = getComputedStyle(ui.container);
                        const paddingTop = parseFloat(computedStyle.paddingTop);
                        const paddingLeft = parseFloat(computedStyle.paddingLeft);
                        const mouseX = e.clientX - rect.left - paddingLeft;
                        const mouseY = e.clientY - rect.top - paddingTop;

                        panX = mouseX - (mouseX - panX) * (newScale / scale);
                        panY = mouseY - (mouseY - panY) * (newScale / scale);
                        scale = newScale;
                    } else { // Handle Pan
                        panX -= e.deltaX;
                        panY -= e.deltaY;
                    }
                    applyTransform();
                    scheduleUIUpdate();
                }, { passive: false });

                ui.container.addEventListener('mousedown', e => {
                    isAnimating = false; // Stop animation on user input
                    e.preventDefault();
                    isPanning = true;
                    panStart.x = e.clientX - panX;
                    panStart.y = e.clientY - panY;
                    ui.zoomWrapper.style.cursor = 'grabbing';
                });

                ui.container.addEventListener('mouseup', () => { isPanning = false; ui.zoomWrapper.style.cursor = 'grab'; });
                ui.container.addEventListener('mouseleave', () => { isPanning = false; ui.zoomWrapper.style.cursor = 'grab'; });

                ui.container.addEventListener('mousemove', e => {
                    if (isPanning) {
                        panX = e.clientX - panStart.x;
                        panY = e.clientY - panStart.y;
                        applyTransform();
                        scheduleUIUpdate();
                    }
                });

                document.addEventListener('keydown', e => {
                    if (e.key !== 'ArrowLeft' && e.key !== 'ArrowRight' || isAnimating) return;

                    const currentPageIndex = parseInt(ui.pageNumSpan.textContent) - 1;
                    let targetIndex = currentPageIndex;

                    if (e.key === 'ArrowLeft') {
                        targetIndex = Math.max(0, currentPageIndex - 1);
                    } else {
                        targetIndex = Math.min(pageContainers.length - 1, currentPageIndex + 1);
                    }

                    if (targetIndex !== currentPageIndex) {
                        const targetPage = pageContainers[targetIndex];
                        const targetRect = targetPage.getBoundingClientRect();
                        const containerRect = ui.container.getBoundingClientRect();
                        const panCorrection = (containerRect.top - targetRect.top) / scale;
                        
                        animatePan(panY + panCorrection);
                    }
                });
            }

            pdfjsLib.getDocument(url).promise.then(pdfDoc_ => {
                pdfDoc = pdfDoc_;
                ui.pageCountSpan.textContent = pdfDoc.numPages;
                return pdfDoc.getPage(1);
            }).then(page => {
                const devicePixelRatio = window.devicePixelRatio || 1;
                const qualityFactor = 2;
                const containerWidth = ui.container.clientWidth - 30;
                const unscaledViewport = page.getViewport({ scale: 1 });
                const scale = containerWidth / unscaledViewport.width;
                const viewport = page.getViewport({ scale: scale * devicePixelRatio * qualityFactor });
                const placeholderHeight = viewport.height / (devicePixelRatio * qualityFactor);

                setupViewer(pdfDoc.numPages, placeholderHeight);

                ui.loader.classList.add('hidden');
                ui.downloadBtn.classList.remove('opacity-0', 'cursor-not-allowed');
                ui.downloadBtn.removeAttribute('aria-disabled');
                
                // Initial Render
                updateUI();
            }).catch(err => {
                ui.loader.classList.add('hidden');
                ui.errorMessage.classList.remove('hidden');
                console.error("Error loading PDF:", err);
            });
        });
    </script>
</body>
</html>


